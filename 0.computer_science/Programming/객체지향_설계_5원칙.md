# 객체지향 설계 5원칙



## SOLID

- `SRP(Single Responsibility Principle): 단일 책임 원칙`
- `OCP(Open Closed Priciple): 개방 폐쇄 원칙`
- `LSP(Listov Substitution Priciple): 리스코프 치환 원칙`
- `ISP(Interface Segregation Principle): 인터페이스 분리 원칙`
- `DIP(Dependency Inversion Principle): 의존 역전 원칙`

## SRP - 단일 책임 원칙

> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C.마틴

- 하나의 클래스는 하나의 역할과 책임을 가져야 한다
  
  ![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e42c949f-abe5-498d-b95a-c0c28acafc99/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221023%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221023T172732Z&X-Amz-Expires=86400&X-Amz-Signature=daa2bb43810938d4e8fb75f2af5c8f11b9cf72715a3bad8ecf03fdb7c4e70f41&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

SRP를 지키지 못한 경우

```java
class 강아지 {
        final static Boolean 수컷 = true;
        final static Boolean 암컷 = false;
        Boolean 성별;

        void 소변보다(){
                if(this.성별 == 수컷) {
                // 한쪽 다리 들고 본다
            } else {
                // 뒷다리 굽혀서 앉은 자세로 본다.
            }
        }
}
```

→ 강아지 클래스 코드의 소변보다() 메소드가 수컷과 암컷 보두를 구현하려고 했기 때문에 단일 책임 원칙을 위반하고 있다.

```java
abstract class 강아지{
        abstract void 소변보다();
}

class 수컷강아지 extends 강아지 {
        void 소변보다()
// 다리
}

class 암컷강아지 extends 강아지 {
        void 소변보다() {
// 뒷
}
}
```

→ ‘강아지’라는 추상 클래스를 두고 수컷과 암컷 클래스의 각각 특징에 맞게 메소드를 구현해서 사용하는 것으로 refactoring 할 수 있다.

객체지향 4대 특성인 캡상추다와 가장 관계 깊은 것으로 모델링 과정을 담당하는 추상화임을 알 수 있다.

## OCP - 개방 폐쇄 원칙

> 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려있어야 하지만 변경에 대해서는 닫혀 있어야 한다. - 로버트 C.마틴

변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화 해야 한다는 의미로, 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다.

- 객체지향의 장점을 극대화하는 중요한 원리

<img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/584673f3-214b-43b2-8380-f43f735843d5/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221023%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221023T172745Z&X-Amz-Expires=86400&X-Amz-Signature=35a2646bd4794e6633687918867d07c129d714bb067aeec4a660b8bc0f3e3b25&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject" title="" alt="" width="518">

- 운전자가 기어의 수동 or 자동에 따라 행동이 달라진다.
- 이럴 경우 변화가 있을 때 운전자가 바로 영향을 받기 때문에 개방 폐쇄 원칙에 위배된다.

<img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/d806fba2-9d11-4a32-be87-f6e0ff5c259b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221023%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221023T172811Z&X-Amz-Expires=86400&X-Amz-Signature=fe9b7a46c8a688a466bb1cf6a88f5459f1cb8196ee837c343b4e765d1153fbb1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject" title="" alt="" width="289">

→ 이렇게 상위 클래스 또는 인터페이스를 중간에 두면 다양한 자동차가 생기더라도 운전 습관에 영향을 받지 않는다.

- 다양한 자동차는 확장성에있어 개방을 의미하고 운전자에 있어선 변화에 폐쇄 되어 있는 것이다.

### 데이터베이스의 개방 폐쇄 원칙의 좋은 예

- JDBC는 가장 좋은 예

<aside>
💡 JDBC란?
자바 프로그램이 데이터베이스와 연결되어 데이터를 주고 받을 수 있게 해주는 프로그래밍 인터페이스

</aside>

<img title="" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/fd10a803-2ea5-4090-8593-a43bef3c0939/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221023%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221023T172754Z&X-Amz-Expires=86400&X-Amz-Signature=7b8e72811a699361f4c8e992018b1dd4464028a10666b8b9cec58a32d3d2361c&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject" alt="" width="453" data-align="center">

- 데이터베이스가 ORACLE에서 MYSQL로 바뀌더라도 connection만 변경해주면 됨

- 즉, 자바 애플리케이션은 db라는 주변의 변화에 닫혀있는 것이다(폐쇄)

- 또한, 데이터 베이스를 교체한다는 것은 자신의 확장에는 열려있는 것(개방)

- 개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.

- 따라서 객체지향 프로그래밍에서 개방 폐쇄 원칙은 반드시 지켜야 할 원칙이다.

## LSP - 리스코프 치환 원칙

> 서브 타입은 언제나 자신의 기반 타입으로 교체 할 수 있어야 한다. - 로버트 C.마틴

- 부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 개체를 완전히 대체할 수있어야 한다.

- `하위 클래스 is a kind of 상위 클래스` - 하위 분류는 상위 분류의 한 종류다.

- `구현 클래스 is able to 인터페이스`: 구현 분류는 인터페이스화할 수 있어야 한다.

### 위배

![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/4da80891-659f-441c-a8e4-6d95e53ca2e6/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221023%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221023T172854Z&X-Amz-Expires=86400&X-Amz-Signature=68e71811f3f0065c27d9cb37d683e78af39e0089054c0bbe616711457f811f62&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

### 만족

![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/279eca06-9699-4760-bdc7-2da97cffb18c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221023%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221023T172903Z&X-Amz-Expires=86400&X-Amz-Signature=c4d34e60042b00f7e26a9a510758a8700c2fe8fa71e862f8b640680e700afb8d&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

## ISP - 인터페이스 분리 원칙

> 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다. - 로버트 C.마틴

- 단일 책임 원칙 (SAP)에서는 하나의 역할(책임)만 하도록 다수의 클래스로 분할하였다면, 인터페이스 분리 원칙은 각 역할에 맞게 인터페이스로 분리하는 것
  
  - ex. 어머니한테는 아들, 여자친구한테는 남자친구
  
  ![](C:\Users\user\AppData\Roaming\marktext\images\2022-10-24-02-29-21-image.png)
  
  - 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.
    
    하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋음

- `상위 클래스는 풍성할수록 좋다.`
  
  - 풍성할수록 하위 클래스에게 많은 기능을 확장시켜주는 것이고, 형변환, 코드 중복을 줄여준다.

- `인터페이스 내에 메소드는 최소한 일수록 좋다.`
  
  - 인터페이스는 하위 클래스에게 구현을 강제하도록 하는 역할 즉, 최소한의 기능만 제공하면서 하나의 역할에 집중하라는 뜻이다.

## DIP - 의존 역전 원칙

> 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
> 
> 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.
> 
> 자주 변경되는 구체(Concrete) 클래스에 의존하지 마라 - 로버트 C.마틴 -

<img src="file:///C:/Users/user/AppData/Roaming/marktext/images/2022-10-24-02-29-45-image.png" title="" alt="" width="646">

- 자동차가 타이어(자주 바뀌는 것)에 의존하게 되면 자동차는 영향을 받게 되어있다.
- 자동차가 구체적 타이어가 아닌 추상화된 타이어 인터페이스에 의존하게 하면 타이어가 변경되어도 자동차가 영향을 받지 않는다.
- 이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.
- 상위 클래스일수록, 인터페이스일수록, 추상 클래스일 수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 의존 역전 원칙이다.
  
  
  
  

[](https://devlog-wjdrbs96.tistory.com/380)[[Java] 객체지향 설계 5원칙 - SOLID란 무엇일까? :: Gyun's 개발일지](https://devlog-wjdrbs96.tistory.com/380)

[](https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle)https://blog.itcode.dev/https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principleposts/2021/08/15/liskov-subsitution-principle
